name: Build Fedora DNF repo for Zen Browser

on:
  # Manual trigger support
  workflow_dispatch: {}

  # Scheduled: Every Friday 6 AM (UTC+6) = 00:00 UTC on Friday
  schedule:
    - cron: "0 0 * * 5"

permissions:
  contents: write # needed to push last_built_version.txt and create releases
  pages: write # needed to deploy to GitHub Pages
  id-token: write # needed by actions/deploy-pages

env:
  REPO_OWNER: ${{ github.repository_owner }}
  REPO_NAME: ${{ github.event.repository.name }}
  PAGES_DIR: public # directory that will be published to GitHub Pages
  DNF_REPO_NAME: zen-browser # name used in .repo instructions
  UPSTREAM_REPO: zen-browser/desktop # upstream to poll for latest releases
  # ARCHS will be set per matrix job
  PACKAGE_NAME: zen-browser # RPM name
  INSTALL_PREFIX: /opt/zen-browser # install location inside the RPM
  CUSTOM_DOMAIN: zenbrowser-dnfrepo.qomarhsn.com

jobs:
  build-and-deploy:
    name: Build RPMs per architecture
    runs-on: ubuntu-latest
    container: fedora:42
    strategy:
      fail-fast: false
      matrix:
        arch: [x86_64, aarch64]
    outputs:
      new_release: ${{ steps.check.outputs.no_change == 'false' }}
      latest_tag: ${{ steps.latest.outputs.tag }}
    env:
      CURRENT_ARCH: ${{ matrix.arch }}

    steps:
      # ------------------------------------------------------------
      # Checkout repository (we will read/write last_built_version.txt)
      # ------------------------------------------------------------
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # ------------------------------------------------------------
      # Install dependencies required for RPM building and repo metadata
      # ------------------------------------------------------------
      - name: Install dependencies
        run: |
          dnf -y install \
            rpm-build redhat-rpm-config createrepo_c jq curl xz file \
            findutils sed tar git which rpm-sign rpmsign expect gnupg2

      # ------------------------------------------------------------
      # Import and setup GPG key for signing
      # ------------------------------------------------------------
      - name: Import GPG key for signing
        run: |
          set -euo pipefail

          # Configure GPG directory and permissions
          mkdir -p ~/.gnupg
          chmod 700 ~/.gnupg

          # Configure GPG for non-interactive use in container
          cat > ~/.gnupg/gpg.conf << EOF
          pinentry-mode loopback
          batch
          no-tty
          EOF
          chmod 600 ~/.gnupg/gpg.conf


          # Import the private key
          echo "${{ secrets.GPG_PRIVATE_KEY }}" | gpg --batch --import

          # Trust the key ultimately (get full fingerprint first)
          FINGERPRINT=$(gpg --list-secret-keys --with-colons ${{ secrets.GPG_KEY_ID }} | grep fpr | head -1 | cut -d: -f10)
          echo "$FINGERPRINT:6:" | gpg --import-ownertrust


          # Test the key
          echo "test" | gpg --batch --yes --pinentry-mode loopback --passphrase "${{ secrets.GPG_PASSPHRASE }}" --clearsign > /dev/null

          echo "GPG key imported and tested successfully"

      # ------------------------------------------------------------
      # Configure RPM signing macros
      # ------------------------------------------------------------
      - name: Configure RPM signing
        run: |
          set -euo pipefail
          # Create .rpmmacros file with proper configuration
          cat > ~/.rpmmacros << EOF
          %_signature gpg
          %_gpg_name ${{ secrets.GPG_KEY_ID }}
          %_gpgbin /usr/bin/gpg
          %__gpg_sign_cmd %{__gpg} gpg --batch --verbose --no-armor --no-secmem-warning --pinentry-mode loopback --passphrase "${{ secrets.GPG_PASSPHRASE }}" -u "%{_gpg_name}" -sbo %{__signature_filename} --digest-algo sha256 %{__plaintext_filename}
          EOF

          # Also set environment variables for rpm command
          echo "GPG_NAME=${{ secrets.GPG_KEY_ID }}" >> $GITHUB_ENV

      # ------------------------------------------------------------
      # Get latest upstream release tag from GitHub API
      # ------------------------------------------------------------
      - name: Fetch latest Zen Browser upstream release
        id: latest
        run: |
          set -euo pipefail
          api_url="https://api.github.com/repos/${UPSTREAM_REPO}/releases/latest"
          json=$(curl -fsSL "$api_url")
          tag=$(echo "$json" | jq -r '.tag_name')
          # Normalize tag if needed; we keep as-is to match upstream asset naming and for the RPM version
          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          # Store the JSON for later consumption (links, notes, etc.)
          echo "$json" > upstream_latest.json

      # ------------------------------------------------------------
      # Compare upstream latest tag with this repo's latest release tag
      # If equal -> skip subsequent work
      # ------------------------------------------------------------
      - name: Determine if rebuild is needed
        id: check
        run: |
          set -euo pipefail

          upstream_latest="${{ steps.latest.outputs.tag }}"

          # Fetch latest release from this repository (may not exist yet)
          self_api_url="https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/releases/latest"
          self_json=$(curl -fsSL "$self_api_url" || echo '{}')
          self_tag=$(echo "$self_json" | jq -r '.tag_name // ""')

          echo "Last built (from this repo's latest release): '${self_tag}'"
          echo "Latest upstream: '${upstream_latest}'"

          if [ -n "$self_tag" ] && [ "$self_tag" = "$upstream_latest" ]; then
            echo "no_change=true" >> "$GITHUB_OUTPUT"
            echo "No new release. Skipping build."
          else
            echo "no_change=false" >> "$GITHUB_OUTPUT"
            echo "New release detected."
          fi

      # ------------------------------------------------------------
      # Prepare rpmbuild tree and download upstream binaries per arch
      # ------------------------------------------------------------
      - name: Prepare build workspace
        if: steps.check.outputs.no_change == 'false'
        run: |
          set -euo pipefail
          mkdir -p work/rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
          mkdir -p "$PAGES_DIR"
          # Snapshot the latest tag for scripting
          echo "${{ steps.latest.outputs.tag }}" > work/LATEST_TAG

      - name: Download upstream tarballs for all architectures
        if: steps.check.outputs.no_change == 'false'
        run: |
          set -euo pipefail
          # Download tarball for current architecture only
          case "$CURRENT_ARCH" in
            x86_64) asset="zen.linux-x86_64.tar.xz" ;;
            aarch64) asset="zen.linux-aarch64.tar.xz" ;;
            *) echo "Unsupported arch: $CURRENT_ARCH" && exit 1 ;;
          esac
          url=$(jq -r --arg name "$asset" '.assets[] | select(.name==$name) | .browser_download_url' upstream_latest.json)
          if [ -z "$url" ] || [ "$url" = "null" ]; then
            echo "Failed to find asset URL for $asset in upstream release. Available assets:" >&2
            jq -r '.assets[].name' upstream_latest.json >&2
            exit 1
          fi
          echo "Downloading $url"
          curl -fL "$url" -o "work/rpmbuild/SOURCES/${asset}"
          # Basic validation
          file "work/rpmbuild/SOURCES/${asset}" || true
          ls -l "work/rpmbuild/SOURCES/${asset}"

      # ------------------------------------------------------------
      # Create a single spec template and build per-arch via --target
      # This spec:
      # - Installs Zen into /opt/zen-browser/
      # - Creates /usr/bin/zen symlink
      # - Uses upstream tag as version (strip leading 'v' for RPM version)
      # ------------------------------------------------------------
      - name: Create desktop/launcher and RPM spec file
        if: steps.check.outputs.no_change == 'false'
        run: |
          set -euo pipefail
          latest_tag=$(cat work/LATEST_TAG)
          # RPM version cannot start with 'v' typically; convert 'v1.2.3' -> '1.2.3'
          rpm_version="${latest_tag#v}"

          # Create desktop entry
          cat > work/rpmbuild/SOURCES/zen-browser.desktop << 'DESK'
          [Desktop Entry]
          Version=1.0
          Name=Zen Browser
          GenericName=Web Browser
          Comment=Experience tranquillity while browsing the web without people tracking you!
          Exec=zen-browser %u
          StartupWMClass=zen
          Icon=zen-browser
          Terminal=false
          Type=Application
          Categories=Network;WebBrowser;
          MimeType=text/html;text/xml;application/xhtml+xml;x-scheme-handler/http;x-scheme-handler/https;application/x-xpinstall;application/pdf;application/json;
          StartupNotify=true
          Actions=new-window;new-private-window;

          [Desktop Action new-window]
          Name=Open a New Window
          Exec=zen-browser --new-window %u

          [Desktop Action new-private-window]
          Name=Open a New Private Window
          Exec=zen-browser --private-window %u
          DESK

          # Create launcher wrapper to enable Wayland and DE integrations when possible
          cat > work/rpmbuild/SOURCES/zen-browser-launcher.sh << 'LAUNCH'
          #!/usr/bin/bash
          set -euo pipefail
          [ -z "${MOZ_DISABLE_WAYLAND:-}" ] && { [ "${XDG_CURRENT_DESKTOP:-}" = "GNOME" ] && [ -n "${WAYLAND_DISPLAY:-}" ] || [ "${XDG_SESSION_TYPE:-}" = "wayland" ]; } && export MOZ_ENABLE_WAYLAND=1 && export MOZ_DBUS_REMOTE=1

          if [ "${XDG_CURRENT_DESKTOP:-}" = "KDE" ] && [ ! -e "${HOME}/.zen/native-messaging-hosts/org.kde.plasma.browser_integration.json" ]; then
              mkdir -p "${HOME}/.zen/native-messaging-hosts"
              [ -r /usr/lib64/mozilla/native-messaging-hosts/org.kde.plasma.browser_integration.json ] && ln -sf /usr/lib64/mozilla/native-messaging-hosts/org.kde.plasma.browser_integration.json "${HOME}/.zen/native-messaging-hosts/org.kde.plasma.browser_integration.json" || true
          fi

          if [ "${XDG_CURRENT_DESKTOP:-}" = "GNOME" ]; then
              mkdir -p "${HOME}/.zen/native-messaging-hosts"
              [ -r /usr/lib64/mozilla/native-messaging-hosts/org.gnome.browser_connector.json ] && ln -sf /usr/lib64/mozilla/native-messaging-hosts/org.gnome.browser_connector.json "${HOME}/.zen/native-messaging-hosts/org.gnome.browser_connector.json" || true
              [ -r /usr/lib64/mozilla/native-messaging-hosts/org.gnome.chrome_gnome_shell.json ] && ln -sf /usr/lib64/mozilla/native-messaging-hosts/org.gnome.chrome_gnome_shell.json "${HOME}/.zen/native-messaging-hosts/org.gnome.chrome_gnome_shell.json" || true
          fi

          export MOZ_APP_LAUNCHER="${0}"

          # Find the actual zen executable
          zen_executable=""
          if [ -x "/opt/zen-browser/zen" ]; then
            zen_executable="/opt/zen-browser/zen"
          elif [ -x "/opt/zen-browser/zen-bin" ]; then
            zen_executable="/opt/zen-browser/zen-bin"
          elif [ -x "/opt/zen-browser/firefox" ]; then
            zen_executable="/opt/zen-browser/firefox"
          else
            # Find any executable file that could be the main binary
            zen_executable="$(find /opt/zen-browser -maxdepth 1 -type f -perm -u=x | head -n1)"
          fi

          if [ -z "$zen_executable" ] || [ ! -x "$zen_executable" ]; then
            echo "Error: Could not find zen executable in /opt/zen-browser" >&2
            exit 1
          fi

          exec "$zen_executable" "$@"
          LAUNCH
          chmod +x work/rpmbuild/SOURCES/zen-browser-launcher.sh

          cat > work/rpmbuild/SPECS/${PACKAGE_NAME}.spec << 'EOF'
          %global _build_id_links none

          Name:           zen-browser
          Version:        RPM_VERSION_PLACEHOLDER
          Release:        1%{?dist}
          Summary:        Zen Browser packaged for Fedora
          License:        MPL-2.0
          URL:            https://github.com/zen-browser/desktop
          Source0:        SOURCE_TARBALL_PLACEHOLDER
          Source1:        zen-browser.desktop
          Source2:        zen-browser-launcher.sh

          BuildArch:      BUILDARCH_PLACEHOLDER
          Requires:       /bin/bash
          # Ensure zen-browser is installed as the primary launcher
          Provides:       zen-browser

          %description
          Zen Browser (Firefork) packaged for Fedora. Installs under /opt/zen-browser with /usr/bin/zen-browser as the primary launcher and /usr/bin/zen as a convenience symlink.

          %prep
          # Nothing to prepare; we will extract in %install

          %build
          # No build step; upstream provides prebuilt binaries

          %install
          rm -rf %{buildroot}
          mkdir -p %{buildroot}%{_prefix}
          mkdir -p %{buildroot}/opt/zen-browser
          mkdir -p %{buildroot}%{_bindir}
          mkdir -p %{buildroot}%{_datadir}/applications

          # Extract source tarball into /opt/zen-browser
          tar -xf %{SOURCE0} -C %{buildroot}/opt/zen-browser --strip-components=1

          # Debug: Show what was extracted
          echo "=== Contents of extracted tarball ==="
          ls -la %{buildroot}/opt/zen-browser/
          echo "=== Executable files ==="
          find %{buildroot}/opt/zen-browser -maxdepth 2 -type f -perm -u=x -ls || true

          # Install wrapper launcher as 'zen-browser' which calls the real binary directly
          install -m 0755 %{SOURCE2} %{buildroot}%{_bindir}/zen-browser

          # Create symlink: /usr/bin/zen -> /usr/bin/zen-browser
          echo "Creating symlink: /usr/bin/zen -> zen-browser"
          ln -sf zen-browser %{buildroot}%{_bindir}/zen

          # Verify the symlink was created correctly
          ls -la %{buildroot}%{_bindir}/zen

          # Install official Zen Browser icon from extracted tarball
          mkdir -p %{buildroot}%{_datadir}/pixmaps
          cp %{buildroot}/opt/zen-browser/browser/chrome/icons/default/default128.png \
             %{buildroot}%{_datadir}/pixmaps/zen-browser.png

          # Install desktop entry
          install -m 0644 %{SOURCE1} %{buildroot}%{_datadir}/applications/zen-browser.desktop

          %files
          /opt/zen-browser
          %{_bindir}/zen
          %{_bindir}/zen-browser
          %{_datadir}/applications/zen-browser.desktop
          %{_datadir}/pixmaps/zen-browser.png

          %changelog
          * Thu Sep 26 2024 GitHub Actions <actions@github.com> - RPM_VERSION_PLACEHOLDER-1
          - Automated build from upstream release.

          EOF

          # We'll parameterize per arch at build-time using sed duplication
          echo "Spec template written."

          echo "$rpm_version" > work/RPM_VERSION

      # ------------------------------------------------------------
      # Build RPMs for both architectures
      # ------------------------------------------------------------
      - name: Build RPMs
        if: steps.check.outputs.no_change == 'false'
        run: |
          set -euo pipefail
          latest_tag=$(cat work/LATEST_TAG)
          rpm_version=$(cat work/RPM_VERSION)

          # Build RPM for current architecture
          case "$CURRENT_ARCH" in
            x86_64) asset="zen.linux-x86_64.tar.xz" ;;
            aarch64) asset="zen.linux-aarch64.tar.xz" ;;
            *) echo "Unsupported arch: $CURRENT_ARCH" && exit 1 ;;
          esac

          spec_in="work/rpmbuild/SPECS/${PACKAGE_NAME}.spec"
          spec_out="work/rpmbuild/SPECS/${PACKAGE_NAME}-${CURRENT_ARCH}.spec"

          # Replace placeholders for this arch
          sed \
            -e "s|RPM_VERSION_PLACEHOLDER|${rpm_version}|g" \
            -e "s|SOURCE_TARBALL_PLACEHOLDER|${asset}|g" \
            -e "s|BUILDARCH_PLACEHOLDER|${CURRENT_ARCH}|g" \
            "$spec_in" > "$spec_out"

          echo "Building RPM for ${CURRENT_ARCH}..."
          # Set QA_RPATHS to ignore invalid RPATHs in upstream binaries (0x0002)
          QA_RPATHS=0x0002 rpmbuild \
            --define "_topdir $PWD/work/rpmbuild" \
            --target "${CURRENT_ARCH}" \
            --nodeps \
            -bb "$spec_out"

          echo "Built RPMs:"
          find work/rpmbuild/RPMS -type f -name "*.rpm" -print

          # Sign all built RPMs
          echo "Signing RPMs..."

          # Set GPG environment variables for container
          export GPG_TTY=/dev/console
          export GNUPGHOME=$HOME/.gnupg

          # Ensure GPG directory exists and has correct permissions
          mkdir -p $HOME/.gnupg
          chmod 700 $HOME/.gnupg


          # Import public key into RPM database for verification
          gpg --armor --export ${{ secrets.GPG_KEY_ID }} > /tmp/pubkey.asc
          rpm --import /tmp/pubkey.asc

          for rpm_file in $(find work/rpmbuild/RPMS -name "*.rpm"); do
            echo "Signing: $rpm_file"
            # Use rpm --addsign with simpler GPG setup
            GNUPGHOME=$HOME/.gnupg \
            rpm --define "_gpg_name ${{ secrets.GPG_KEY_ID }}" \
                --define "_signature gpg" \
                --define "__gpg_sign_cmd %{__gpg} gpg --batch --no-armor --no-secmem-warning --pinentry-mode loopback --passphrase '${{ secrets.GPG_PASSPHRASE }}' -u %{_gpg_name} -sbo %{__signature_filename} --digest-algo sha256 %{__plaintext_filename}" \
                --addsign "$rpm_file"
            
            # Verify signature
            echo "Verifying signature for: $rpm_file"
            rpm -K "$rpm_file"
          done

      # ------------------------------------------------------------
      # Assemble DNF repository and generate metadata
      # ------------------------------------------------------------
      - name: Upload RPM artifacts for this architecture
        if: steps.check.outputs.no_change == 'false'
        uses: actions/upload-artifact@v4
        with:
          name: rpm-${{ env.CURRENT_ARCH }}
          path: work/rpmbuild/RPMS

  # ------------------------------------------------------------
  # Aggregate RPMs from all architectures, build repo, sign, deploy, release
  # ------------------------------------------------------------
  aggregate-and-deploy:
    name: Aggregate RPMs, build repo, and release
    runs-on: ubuntu-latest
    container: fedora:42
    needs: build-and-deploy
    if: needs.build-and-deploy.outputs.new_release == 'true'
    env:
      PAGES_DIR: public
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download RPM artifacts (all architectures)
        uses: actions/download-artifact@v4
        with:
          path: aggregated-rpms

      - name: Install createrepo_c and GPG
        run: |
          set -euo pipefail
          dnf -y install createrepo_c gnupg2 curl jq

      - name: Prepare public repo directory and copy RPMs
        run: |
          set -euo pipefail
          mkdir -p "$PAGES_DIR"
          find aggregated-rpms -type f -name "*.rpm" -exec cp -v {} "$PAGES_DIR"/ \;

      - name: Create DNF repo (createrepo_c)
        run: |
          set -euo pipefail
          createrepo_c "$PAGES_DIR"
          echo "Repo contents:"
          ls -la "$PAGES_DIR"
          echo "repodata:"
          ls -la "$PAGES_DIR/repodata"

      - name: Sign repository metadata
        run: |
          set -euo pipefail

          # Export public key to repository
          gpg --armor --export ${{ secrets.GPG_KEY_ID }} > "$PAGES_DIR/RPM-GPG-KEY-zen-browser"

          # Sign repository metadata
          gpg --batch --yes --pinentry-mode loopback --passphrase "${{ secrets.GPG_PASSPHRASE }}" \
              --detach-sign --armor "$PAGES_DIR/repodata/repomd.xml"

          # Verify the signature
          gpg --verify "$PAGES_DIR/repodata/repomd.xml.asc" "$PAGES_DIR/repodata/repomd.xml"

          echo "Repository metadata signed successfully"
          echo "Repository contents:"
          ls -la "$PAGES_DIR"
          echo "Signature file:"
          ls -la "$PAGES_DIR/repodata/repomd.xml.asc"

      - name: Setup Pages
        uses: actions/configure-pages@v5
        with:
          enablement: true

      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: ${{ env.PAGES_DIR }}

      - name: Deploy to GitHub Pages
        id: deploy
        uses: actions/deploy-pages@v4

      - name: Create GitHub Release with instructions
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ needs.build-and-deploy.outputs.latest_tag }}
          name: Zen Browser ${{ needs.build-and-deploy.outputs.latest_tag }}
          body: |
            ## Changelog

            See upstream release: [zen-browser/desktop@${{ needs.build-and-deploy.outputs.latest_tag }}](https://github.com/${{ env.UPSTREAM_REPO }}/releases/tag/${{ needs.build-and-deploy.outputs.latest_tag }})

            ## Installation

            ### Import GPG Key (Required)
            ```bash
            sudo rpm --import https://${{ env.CUSTOM_DOMAIN }}/RPM-GPG-KEY-zen-browser
            ```

            ### Add repository
            ```bash
            sudo tee /etc/yum.repos.d/zen-browser.repo > /dev/null << 'REPO'
            [zen-browser]
            name=Zen Browser
            baseurl=https://${{ env.CUSTOM_DOMAIN }}/
            enabled=1
            gpgcheck=1
            repo_gpgcheck=1
            gpgkey=https://${{ env.CUSTOM_DOMAIN }}/RPM-GPG-KEY-zen-browser
            skip_if_unavailable=True
            metadata_expire=6h
            REPO
            ```

            ### Install
            ```bash
            sudo dnf clean all
            sudo dnf update -y
            sudo dnf install -y zen-browser
            ```

            **ðŸ”’ This release includes GPG-signed packages and repository metadata for enhanced security.**

            Full instructions: **[zenbrowser-dnfrepo.qomarhsn.com](https://${{ env.CUSTOM_DOMAIN }})**

          draft: false
          prerelease: false
          files: |
            public/*.rpm
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
